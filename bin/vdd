#!/usr/bin/perl -w
#
# vdd
# Vim Debugger Daemon
#
#
# (c) eric johnson 2002-3020
# distribution under the GPL
#
# email: vimDebug at iijo dot org
# http://iijo.org
#
# $Id: vdd 87 2006-02-09 05:01:31Z eric $

use strict;
use File::Basename;
use Getopt::Long;
use vars qw(
   $unix $sessionId $debuggerName $sourcePath @commandLineOptions $help_option
   $TOvim $FROMvim $debugger $debug_option $color_option
);

$unix         = 1; # valid values are 1 and 0
$debug_option = 0;
$color_option = 0;

$SIG{INT} = \&signalHandler;
getCommandLineOptions();
init();
main();


sub signalHandler {
   exit;
}


sub getCommandLineOptions {

   usage() unless(scalar(@ARGV) >= 3);

   $sessionId          = shift @ARGV;   # session id
   $debuggerName       = shift @ARGV;   # which debugger to use
   $sourcePath         = shift @ARGV;   # path to source you want to debug
   @commandLineOptions = @ARGV;         # command line options of program

}


sub usage {
   print "
Usage: vdd SESSION_ID DEBUGGER SOURCEPATH [DBGR_CMDLINE_OPTS]

The vim debugger daemon uses the perl module VimDebug::Debugger::DEBUGGER to
invoke a debugger on the code in the program located at SOURCEPATH.
Communication with the daemon occurs via fifos located at
\".vddTOvim.SESSION_ID\" and \".vimTOvdd.SESSION_ID\".  Any command line
options are passed on to the debugger.

"; exit(0);
}


sub init {
   $| = 1;

   $TOvim   = ".vddTOvim." . $sessionId;   # fifo to write to   VIM
   $FROMvim = ".vimTOvdd." . $sessionId;   # fifo to read  from VIM

   if ($color_option) {
      eval('require Term::ANSIColor;import Term::ANSIColor;') and
         warn "fancy color printing disabled.  couldn't find Term::ANSIColor\n";
   }
}


sub main {

   makeNamedPipe($FROMvim);
   makeNamedPipe($TOvim);
   startDebugger();

   # loop until request to exit
   while (1) {
      my $command = readFromVim();     # blocks until there is something to read

      for ($command) {   # this works like a switch statement
         /^next$/o                     and _next($command)             and last;
         /^step$/o                     and step($command)              and last;
         /^break:\d+:\S+$/o            and setBreakPoint($command)     and last;
         /^clear:\d+:\S+$/o            and clearBreakPoint($command)   and last;
         /^clearAll$/o                 and clearAllBreakPoints()       and last;
         /^cont$/o                     and cont()                      and last;
         /^printExpression:.+$/o       and printExpression($command)   and last;
         /^command:.+$/o               and command($command)           and last;
         /^restart$/o                  and restart()                   and last;
         /^quit$/o                     and quit()                      and last;
         sendToVim("vdd: bad command");
      }
   }

}

sub END {
   close $FROMvim    if defined $FROMvim;
   close $TOvim      if defined $TOvim;

   unlink $FROMvim   if defined $FROMvim;
   unlink $TOvim     if defined $TOvim;
   exit;
}


sub makeNamedPipe {
   my $fifo = shift or die "gotta pass a fifo to this function";

   # if pipe is already there, die
   if (-p $fifo) {
      print "vdd: $fifo already exists.  perhaps another instance of" .
            " vimDebug is running?\nif not, just delete $fifo.\n";
      exit();
   }

   #if( unix() )   {
      if(    system( 'mkfifo', $fifo )
          && system( 'mknod',  $fifo, 'p' ) )   {
         die "is mkfifo or mknod in your path?\n";
      }
   #}
   #elsif( dos() )   {
   #   die "not yet implemented for a microsoft operating system\n";
   #}
}


sub logger {
   my $printMe = shift or die;
   my $color   = (shift or color("blue"));

   $color_option ?
      print $color, $printMe, color("white"), "\n"
    : print "[" . $printMe . "]\n";
}



### debugger related subroutines ###############################################


# blocks until there is something to read
sub readFromVim {
   open(FROMvim, "< $FROMvim") or quit();
   my $from = <FROMvim>;
   logger("received '$from'") if $debug_option;
   return $from;
}


# blocks until someone reads
# obviously this stuff isn't going to work on windows.  for windows we
# should use gvim --remote stuff.  i don't want to use gvim on unix because
# then you can't debug over a telnet session.
sub sendToVim {
   my $stuffToSend = shift;

   logger("sending  '$stuffToSend'") if $debug_option;
   open(TOvim, "> $TOvim") or quit();
   print TOvim $stuffToSend;
   close(TOvim);
}

sub startDebugger {

   # load module
   my $moduleName = 'VimDebug/Debugger/' . $debuggerName . '.pm';
   require $moduleName ;

   # create debugger object
   $debuggerName = 'VimDebug::Debugger::' . $debuggerName;
   $debugger = eval $debuggerName . "->new();";
   die "no such module exists: $debuggerName" unless defined $debugger;

   sendToVim($debugger->startDebugger($sourcePath, @commandLineOptions));
}


# "_next()" is named funny because "next" is a perl keyword
sub _next {
   sendToVim($debugger->next());
}


sub step {
   sendToVim($debugger->step());
}


sub cont {
   sendToVim($debugger->cont());
}


sub setBreakPoint {
   my $command = shift or die;

   $command =~ /^break:(\d+):(.*)$/o or die;
   my $lineNumber = $1;
   my $fileName = $2;

   sendToVim($debugger->setBreakPoint($lineNumber, $fileName));
}

sub clearBreakPoint {
   my $command = shift or die;

   $command =~ /^clear:(\d+):(.*)$/o or die;
   my $lineNumber = $1;
   my $fileName = $2;

   sendToVim($debugger->clearBreakPoint($lineNumber, $fileName));
}


sub clearAllBreakPoints {
   sendToVim($debugger->clearAllBreakPoints());
}


sub printExpression {
   my $command = shift or die;
   $command =~ /^printExpression:(.+)$/o or die;
   my $expressionToPrint = $1;

   sendToVim($debugger->printExpression($expressionToPrint));
}


sub command {
   my $command = shift or die;
   $command =~ /^command:(.+)$/o or die;
   $command = $1;

   sendToVim($debugger->command($command));
}


sub restart {
   sendToVim($debugger->restart());
}

sub quit {
   $debugger->quit() if defined $debugger;
   exit();
}
